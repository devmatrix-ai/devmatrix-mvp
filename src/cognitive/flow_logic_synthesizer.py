"""
Flow Logic Synthesizer - Emits executable code from ICBR.

This is the final stage of the Behavior Logic Pipeline:
  BehaviorModelIR → ICBR → FlowLogicSynthesizer → Generated Code

Responsibilities:
- Generate guard check functions
- Generate transition validation functions  
- Generate invariant check functions
- Emit code that integrates with services
"""
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import logging
import textwrap

from .ir.icbr import (
    ICBR, CanonicalPredicate, CanonicalGuard, AtomicOperation,
    StateTransition, CanonicalInvariant, PredicateType
)

logger = logging.getLogger(__name__)


@dataclass
class SynthesizedCode:
    """Result of code synthesis."""
    guards: Dict[str, str]       # guard_id → python code
    transitions: Dict[str, str]  # transition_id → python code
    invariants: Dict[str, str]   # invariant_id → python code
    imports: List[str]
    
    def get_all_code(self) -> str:
        """Get all synthesized code as single string."""
        parts = []
        parts.append("# Auto-generated by FlowLogicSynthesizer")
        parts.append("from fastapi import HTTPException")
        parts.extend(self.imports)
        parts.append("")
        
        for guard_id, code in self.guards.items():
            parts.append(f"# Guard: {guard_id}")
            parts.append(code)
            parts.append("")
        
        for trans_id, code in self.transitions.items():
            parts.append(f"# Transition: {trans_id}")
            parts.append(code)
            parts.append("")
        
        for inv_id, code in self.invariants.items():
            parts.append(f"# Invariant: {inv_id}")
            parts.append(code)
            parts.append("")
        
        return "\n".join(parts)


class FlowLogicSynthesizer:
    """
    Synthesizes executable Python code from ICBR.
    
    This is deterministic: same ICBR → same code output.
    """
    
    def __init__(self):
        self.indent = "    "
    
    def synthesize(self, icbr: ICBR) -> SynthesizedCode:
        """Synthesize code from ICBR."""
        result = SynthesizedCode(
            guards={},
            transitions={},
            invariants={},
            imports=[]
        )
        
        # Synthesize guards
        for guard_id, guard in icbr.guards.items():
            code = self._synthesize_guard(guard, icbr.predicates)
            if code:
                result.guards[guard_id] = code
        
        # Synthesize transitions
        for trans_id, transition in icbr.transitions.items():
            code = self._synthesize_transition(transition)
            if code:
                result.transitions[trans_id] = code
        
        # Synthesize invariants
        for inv_id, invariant in icbr.invariants.items():
            code = self._synthesize_invariant(invariant, icbr.predicates)
            if code:
                result.invariants[inv_id] = code
        
        logger.info(f"Synthesized: {len(result.guards)} guards, "
                   f"{len(result.transitions)} transitions, "
                   f"{len(result.invariants)} invariants")
        
        return result
    
    def _synthesize_guard(
        self, 
        guard: CanonicalGuard, 
        predicates: Dict[str, CanonicalPredicate]
    ) -> str:
        """Synthesize a guard function."""
        func_name = self._to_function_name(guard.guard_id)
        
        # Build conditions
        conditions = []
        for pred_id in guard.predicates:
            if pred_id in predicates:
                pred = predicates[pred_id]
                conditions.append(pred.to_python_expression())
        
        if not conditions:
            return ""
        
        condition_str = " and ".join(conditions)
        
        code = textwrap.dedent(f'''
        def {func_name}(**context):
            """Guard: {guard.name}"""
            if not ({condition_str}):
                raise HTTPException(
                    status_code={guard.error_code},
                    detail="{guard.error_message}"
                )
        ''').strip()
        
        return code
    
    def _synthesize_transition(self, transition: StateTransition) -> str:
        """Synthesize a transition validation function."""
        func_name = self._to_function_name(transition.transition_id)
        entity_lower = transition.entity.lower()
        
        code = textwrap.dedent(f'''
        def {func_name}({entity_lower}, new_status: str):
            """Validate transition: {transition.from_state} → {transition.to_state}"""
            current = getattr({entity_lower}, 'status', None)
            valid_transitions = {{
                '{transition.from_state}': ['{transition.to_state}'],
            }}
            
            if current not in valid_transitions:
                raise HTTPException(
                    status_code=422,
                    detail=f"Cannot transition from status '{{current}}'"
                )
            
            if new_status not in valid_transitions.get(current, []):
                raise HTTPException(
                    status_code=422,
                    detail=f"Cannot transition from '{{current}}' to '{{new_status}}'"
                )
        ''').strip()
        
        return code
    
    def _synthesize_invariant(
        self,
        invariant: CanonicalInvariant,
        predicates: Dict[str, CanonicalPredicate]
    ) -> str:
        """Synthesize an invariant check function."""
        func_name = self._to_function_name(invariant.invariant_id)
        entity_lower = invariant.entity.lower()
        
        pred = predicates.get(invariant.predicate_id)
        condition = pred.to_python_expression() if pred else "True"
        
        code = textwrap.dedent(f'''
        def {func_name}({entity_lower}):
            """Invariant: {invariant.description}"""
            if not ({condition}):
                raise HTTPException(
                    status_code=422,
                    detail="Invariant violated: {invariant.description}"
                )
        ''').strip()
        
        return code
    
    def _to_function_name(self, identifier: str) -> str:
        """Convert identifier to valid Python function name."""
        name = identifier.replace(':', '_').replace('-', '_').replace('.', '_')
        name = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        if name[0].isdigit():
            name = 'f_' + name
        return name

