"""
Template Stratum Patterns - Static Infrastructure

These patterns are NEVER generated by LLM. They are:
- Pre-tested and validated
- Static across all projects
- Immutable boilerplate

Stratum: TEMPLATE (highest trust, no LLM involvement)
"""

from typing import Dict, Any, Optional, List
from dataclasses import dataclass


@dataclass
class TemplatePattern:
    """Static template pattern - never regenerated."""
    name: str
    file_path: str
    code: str
    description: str
    domain: str
    success_rate: float = 1.0  # Pre-tested = 100%


# =============================================================================
# DOCKER & INFRASTRUCTURE TEMPLATES
# =============================================================================

DOCKERFILE_TEMPLATE = TemplatePattern(
    name="dockerfile_multistage",
    file_path="Dockerfile",
    description="Multi-stage Dockerfile for Python FastAPI",
    domain="infrastructure",
    code='''FROM python:3.11-slim as builder

WORKDIR /app

RUN apt-get update && apt-get install -y --no-install-recommends \\
    build-essential \\
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip wheel --no-cache-dir --no-deps --wheel-dir /app/wheels -r requirements.txt

FROM python:3.11-slim

WORKDIR /app

RUN apt-get update && apt-get install -y --no-install-recommends \\
    libpq5 \\
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/wheels /wheels
RUN pip install --no-cache /wheels/*

COPY src/ ./src/
COPY alembic/ ./alembic/
COPY alembic.ini .

ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

EXPOSE 8000

CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
)

DOCKER_COMPOSE_TEMPLATE = TemplatePattern(
    name="docker_compose_full",
    file_path="docker-compose.yml",
    description="Full stack docker-compose with PostgreSQL",
    domain="infrastructure",
    code='''version: "3.8"

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://postgres:postgres@db:5432/app
      - ENVIRONMENT=development
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=app
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
'''
)

PROMETHEUS_CONFIG_TEMPLATE = TemplatePattern(
    name="prometheus_config",
    file_path="prometheus.yml",
    description="Prometheus configuration for API metrics",
    domain="observability",
    code='''global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'api'
    static_configs:
      - targets: ['api:8000']
    metrics_path: '/metrics'
'''
)


# =============================================================================
# PROJECT CONFIG TEMPLATES
# =============================================================================

REQUIREMENTS_TEMPLATE = TemplatePattern(
    name="requirements_txt",
    file_path="requirements.txt",
    description="Standard Python dependencies for FastAPI project",
    domain="configuration",
    code='''fastapi>=0.109.0
uvicorn[standard]>=0.27.0
sqlalchemy[asyncio]>=2.0.25
asyncpg>=0.29.0
alembic>=1.13.1
pydantic>=2.5.0
pydantic-settings>=2.1.0
python-dotenv>=1.0.0
structlog>=24.1.0
prometheus-client>=0.19.0
httpx>=0.26.0
'''
)

PYPROJECT_TEMPLATE = TemplatePattern(
    name="pyproject_toml",
    file_path="pyproject.toml",
    description="Standard pyproject.toml configuration",
    domain="configuration",
    code='''[build-system]
requires = ["setuptools>=68.0"]
build-backend = "setuptools.build_meta"

[project]
name = "generated-api"
version = "0.1.0"
requires-python = ">=3.11"

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
python_files = ["test_*.py"]
python_functions = ["test_*"]

[tool.ruff]
line-length = 100
target-version = "py311"

[tool.ruff.lint]
select = ["E", "F", "W", "I", "N", "UP", "B", "C4"]
ignore = ["E501"]

[tool.mypy]
python_version = "3.11"
strict = true
ignore_missing_imports = true
'''
)

ENV_EXAMPLE_TEMPLATE = TemplatePattern(
    name="env_example",
    file_path=".env.example",
    description="Environment variables template",
    domain="configuration",
    code='''# Database
DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/app

# Environment
ENVIRONMENT=development
DEBUG=true

# API
API_V1_PREFIX=/api/v1
PROJECT_NAME=Generated API

# Security
SECRET_KEY=change-me-in-production
'''
)

ALEMBIC_INI_TEMPLATE = TemplatePattern(
    name="alembic_ini",
    file_path="alembic.ini",
    description="Alembic configuration",
    domain="configuration",
    code='''[alembic]
script_location = alembic
prepend_sys_path = .
version_path_separator = os

[post_write_hooks]

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
'''
)


# =============================================================================
# CORE MODULE TEMPLATES
# =============================================================================

CONFIG_PY_TEMPLATE = TemplatePattern(
    name="core_config",
    file_path="src/core/config.py",
    description="Pydantic settings configuration",
    domain="configuration",
    code='''"""Application configuration using Pydantic Settings."""

from functools import lru_cache
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )

    # Database
    database_url: str = "postgresql+asyncpg://postgres:postgres@localhost:5432/app"

    # Environment
    environment: str = "development"
    debug: bool = False

    # API
    api_v1_prefix: str = "/api/v1"
    project_name: str = "Generated API"

    @property
    def is_development(self) -> bool:
        return self.environment == "development"

    @property
    def is_production(self) -> bool:
        return self.environment == "production"


@lru_cache
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()


settings = get_settings()
'''
)

DATABASE_PY_TEMPLATE = TemplatePattern(
    name="core_database",
    file_path="src/core/database.py",
    description="Async SQLAlchemy database setup",
    domain="data_access",
    code='''"""Async database configuration with SQLAlchemy."""

from typing import AsyncGenerator

from sqlalchemy.ext.asyncio import (
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import DeclarativeBase

from src.core.config import settings


class Base(DeclarativeBase):
    """Base class for SQLAlchemy models."""
    pass


engine = create_async_engine(
    settings.database_url,
    echo=settings.debug,
    pool_pre_ping=True,
    pool_size=5,
    max_overflow=10,
)

async_session_maker = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False,
)


async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Dependency to get async database session."""
    async with async_session_maker() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
'''
)


# =============================================================================
# API TEMPLATES
# =============================================================================

MAIN_PY_TEMPLATE = TemplatePattern(
    name="main_app",
    file_path="src/main.py",
    description="FastAPI application entry point",
    domain="api",
    code='''"""FastAPI application entry point."""

from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from src.core.config import settings
from src.api.routes import health


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Application lifespan context manager."""
    # Startup
    yield
    # Shutdown


app = FastAPI(
    title=settings.project_name,
    openapi_url=f"{settings.api_v1_prefix}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan,
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"] if settings.is_development else [],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(health.router, tags=["Health"])
'''
)

HEALTH_ROUTES_TEMPLATE = TemplatePattern(
    name="health_routes",
    file_path="src/api/routes/health.py",
    description="Health check endpoints",
    domain="api",
    code='''"""Health check endpoints."""

from fastapi import APIRouter, Depends
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.database import get_db


router = APIRouter()


@router.get("/health")
async def health_check() -> dict:
    """Basic health check endpoint."""
    return {"status": "healthy"}


@router.get("/health/ready")
async def readiness_check(db: AsyncSession = Depends(get_db)) -> dict:
    """Readiness check with database connectivity."""
    try:
        await db.execute(text("SELECT 1"))
        return {"status": "ready", "database": "connected"}
    except Exception as e:
        return {"status": "not_ready", "database": str(e)}
'''
)

BASE_REPOSITORY_TEMPLATE = TemplatePattern(
    name="base_repository",
    file_path="src/repositories/base.py",
    description="Generic async repository base class",
    domain="data_access",
    code='''"""Base repository with generic async CRUD operations."""

from typing import Generic, TypeVar, Optional, List, Type
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.database import Base


ModelT = TypeVar("ModelT", bound=Base)


class BaseRepository(Generic[ModelT]):
    """Base repository with async CRUD operations."""

    def __init__(self, model: Type[ModelT], session: AsyncSession):
        self.model = model
        self.session = session

    async def get(self, id: UUID) -> Optional[ModelT]:
        """Get entity by ID."""
        return await self.session.get(self.model, id)

    async def get_all(
        self,
        skip: int = 0,
        limit: int = 100
    ) -> List[ModelT]:
        """Get all entities with pagination."""
        query = select(self.model).offset(skip).limit(limit)
        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def create(self, obj: ModelT) -> ModelT:
        """Create new entity."""
        self.session.add(obj)
        await self.session.flush()
        await self.session.refresh(obj)
        return obj

    async def update(self, obj: ModelT) -> ModelT:
        """Update existing entity."""
        await self.session.flush()
        await self.session.refresh(obj)
        return obj

    async def delete(self, obj: ModelT) -> None:
        """Delete entity."""
        await self.session.delete(obj)
        await self.session.flush()
'''
)


# =============================================================================
# ALEMBIC TEMPLATES
# =============================================================================

ALEMBIC_ENV_TEMPLATE = TemplatePattern(
    name="alembic_env",
    file_path="alembic/env.py",
    description="Alembic migrations environment",
    domain="data_access",
    code='''"""Alembic migrations environment configuration."""

import asyncio
from logging.config import fileConfig

from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

from alembic import context

from src.core.config import settings
from src.core.database import Base
from src.models.entities import *  # noqa: F401, F403

config = context.config

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

config.set_main_option("sqlalchemy.url", settings.database_url)


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    """Run migrations with connection."""
    context.configure(connection=connection, target_metadata=target_metadata)

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """Run async migrations."""
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    asyncio.run(run_async_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
'''
)


# =============================================================================
# TEMPLATE REGISTRY
# =============================================================================

TEMPLATE_PATTERNS: Dict[str, TemplatePattern] = {
    # Infrastructure
    "dockerfile": DOCKERFILE_TEMPLATE,
    "docker_compose": DOCKER_COMPOSE_TEMPLATE,
    "prometheus": PROMETHEUS_CONFIG_TEMPLATE,

    # Project config
    "requirements": REQUIREMENTS_TEMPLATE,
    "pyproject": PYPROJECT_TEMPLATE,
    "env_example": ENV_EXAMPLE_TEMPLATE,
    "alembic_ini": ALEMBIC_INI_TEMPLATE,

    # Core modules
    "config": CONFIG_PY_TEMPLATE,
    "database": DATABASE_PY_TEMPLATE,

    # API
    "main": MAIN_PY_TEMPLATE,
    "health_routes": HEALTH_ROUTES_TEMPLATE,
    "base_repository": BASE_REPOSITORY_TEMPLATE,

    # Alembic
    "alembic_env": ALEMBIC_ENV_TEMPLATE,
}


def get_template(name: str) -> Optional[TemplatePattern]:
    """Get template by name."""
    return TEMPLATE_PATTERNS.get(name)


def get_template_for_file(file_path: str) -> Optional[TemplatePattern]:
    """Get template for a specific file path."""
    for template in TEMPLATE_PATTERNS.values():
        if file_path.endswith(template.file_path) or template.file_path in file_path:
            return template
    return None


def get_all_templates() -> Dict[str, TemplatePattern]:
    """Get all template patterns."""
    return TEMPLATE_PATTERNS.copy()


def is_template_file(file_path: str) -> bool:
    """Check if a file should use TEMPLATE stratum."""
    return get_template_for_file(file_path) is not None
