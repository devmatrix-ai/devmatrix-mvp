"""
Seed Data Agent

Phase 3 of Bug #107: LLM-Driven Smoke Test Generation

Generates seed_db.py script from SmokeTestPlan and IR.
Ensures FK dependencies are respected and entities created in correct order.
"""
import json
import structlog
from typing import List, Dict, Any, Optional

from src.cognitive.ir.application_ir import ApplicationIR
from src.llm.enhanced_anthropic_client import EnhancedAnthropicClient
from src.validation.smoke_test_models import SmokeTestPlan, SeedDataEntity

logger = structlog.get_logger(__name__)


SEED_TEMPLATE = '''#!/usr/bin/env python3
"""
Database Initialization and Seed Script

Generated by SeedDataAgent for smoke testing.
Run this before starting the app to ensure test resources exist.

Usage:
    python scripts/seed_db.py
"""
import asyncio
import os
import sys

# Add project root to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import structlog

logger = structlog.get_logger(__name__)


async def init_database():
    """Initialize database tables."""
    from src.core.database import init_db
    logger.info("ðŸ”„ Creating database tables (if not exists)...")
    try:
        await init_db()
        logger.info("âœ… Database tables created")
    except Exception as e:
        if "already exists" in str(e).lower():
            logger.info("â„¹ï¸ Tables already exist (alembic ran first)")
        else:
            raise


async def seed_test_data():
    """Seed minimal test data for smoke testing."""
    from src.core.database import get_db

    logger.info("ðŸŒ± Seeding test data...")

    async for session in get_db():
        try:
{seed_entries}
            await session.commit()
            logger.info("âœ… Test data seeded successfully")
        except Exception as e:
            await session.rollback()
            # Ignore duplicate key errors (data already exists)
            if "duplicate key" in str(e).lower() or "unique constraint" in str(e).lower():
                logger.info("â„¹ï¸ Test data already exists, skipping seed")
            else:
                logger.error(f"âŒ Failed to seed data: {{e}}")
                raise
        break  # Only need one session


async def main():
    """Initialize database and seed test data."""
    logger.info("ðŸš€ Starting database initialization...")

    try:
        await init_database()
        await seed_test_data()
        logger.info("âœ… Database initialization complete!")
    except Exception as e:
        logger.error(f"âŒ Database initialization failed: {{e}}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
'''


class SeedDataAgent:
    """
    Agent for generating seed_db.py from SmokeTestPlan.

    Deterministic: Generates code directly from plan without LLM for simple cases.
    Uses LLM only for complex field value generation.
    """

    def __init__(self, llm_client: Optional[EnhancedAnthropicClient] = None):
        self.llm = llm_client or EnhancedAnthropicClient()

    def generate_seed_script(
        self,
        plan: SmokeTestPlan,
        ir: ApplicationIR
    ) -> str:
        """
        Generate seed_db.py from SmokeTestPlan.

        Args:
            plan: SmokeTestPlan with seed_data
            ir: ApplicationIR for entity schema reference

        Returns:
            Complete seed_db.py script as string
        """
        logger.info("ðŸŒ± Seed Data Agent: Generating seed script from plan")

        # Sort entities by dependencies (topological sort)
        sorted_entities = self._sort_by_dependencies(plan.seed_data, ir)

        # Generate seed entries
        seed_entries = self._generate_seed_entries(sorted_entities, ir)

        # Fill template
        script = SEED_TEMPLATE.format(seed_entries=seed_entries)

        logger.info(f"   âœ… Generated seed script with {len(sorted_entities)} entities")

        return script

    def _sort_by_dependencies(
        self,
        entities: List[SeedDataEntity],
        ir: ApplicationIR
    ) -> List[SeedDataEntity]:
        """Sort entities so parents come before children (FK dependencies)."""
        # Build dependency graph from IR relationships
        entity_deps: Dict[str, List[str]] = {}
        for entity in ir.get_entities():
            deps = []
            for rel in entity.relationships:
                # many_to_one means this entity depends on target
                if rel.type.value == "many_to_one" or rel.type.name == "MANY_TO_ONE":
                    deps.append(rel.target_entity)
            entity_deps[entity.name] = deps

        # Map seed entities by name
        entity_map = {e.entity_name: e for e in entities}

        # Topological sort
        sorted_names: List[str] = []
        visited = set()
        temp_visited = set()

        def visit(name: str):
            if name in temp_visited:
                return  # Cycle, ignore
            if name in visited:
                return
            temp_visited.add(name)

            # Visit dependencies first
            for dep in entity_deps.get(name, []):
                if dep in entity_map:
                    visit(dep)

            temp_visited.remove(name)
            visited.add(name)
            sorted_names.append(name)

        for entity in entities:
            visit(entity.entity_name)

        # Return sorted entities
        return [entity_map[name] for name in sorted_names if name in entity_map]

    def _generate_seed_entries(
        self,
        entities: List[SeedDataEntity],
        ir: ApplicationIR
    ) -> str:
        """Generate Python code for each seed entity."""
        entries = []

        for entity in entities:
            entry = self._generate_entity_entry(entity, ir)
            entries.append(entry)

        return '\n'.join(entries)

    def _generate_entity_entry(
        self,
        entity: SeedDataEntity,
        ir: ApplicationIR
    ) -> str:
        """Generate Python code for a single entity."""
        entity_class = f"{entity.entity_name}Entity"
        var_name = f"test_{entity.entity_name.lower()}"

        # Build field assignments
        field_lines = [f"id=UUID(\"{entity.uuid}\")"]

        # Get entity schema from IR
        ir_entity = next(
            (e for e in ir.get_entities() if e.name == entity.entity_name),
            None
        )

        for field_name, field_value in entity.fields.items():
            # Check if field is a FK (UUID type pointing to another entity)
            is_fk = False
            if ir_entity:
                for rel in ir_entity.relationships:
                    if rel.field_name == field_name:
                        is_fk = True
                        break

            # Format value
            if is_fk and isinstance(field_value, str) and self._looks_like_uuid(field_value):
                field_lines.append(f"{field_name}=UUID(\"{field_value}\")")
            elif isinstance(field_value, str):
                field_lines.append(f"{field_name}=\"{field_value}\"")
            elif isinstance(field_value, bool):
                field_lines.append(f"{field_name}={field_value}")
            elif isinstance(field_value, (int, float)):
                field_lines.append(f"{field_name}={field_value}")
            else:
                # For complex types, use repr
                field_lines.append(f"{field_name}={repr(field_value)}")

        fields_str = ",\n                ".join(field_lines)

        return f'''            # Seed {entity.entity_name} with predictable UUID for smoke testing
            from src.models.entities import {entity_class}
            from uuid import UUID
            {var_name} = {entity_class}(
                {fields_str}
            )
            session.add({var_name})
            logger.info("âœ… Created test {entity.entity_name} with ID {entity.uuid}")'''

    def _looks_like_uuid(self, value: str) -> bool:
        """Check if string looks like a UUID."""
        import re
        uuid_pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
        return bool(re.match(uuid_pattern, value, re.IGNORECASE))
