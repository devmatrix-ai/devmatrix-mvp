"""
Seed Data Agent

Phase 3 of Bug #107: LLM-Driven Smoke Test Generation

Generates seed_db.py script from SmokeTestPlan and IR.
Ensures FK dependencies are respected and entities created in correct order.
"""
import json
import structlog
from typing import List, Dict, Any, Optional

from src.cognitive.ir.application_ir import ApplicationIR
from src.llm.enhanced_anthropic_client import EnhancedAnthropicClient
from src.validation.smoke_test_models import SmokeTestPlan, SeedDataEntity

logger = structlog.get_logger(__name__)


SEED_TEMPLATE = '''#!/usr/bin/env python3
"""
Database Initialization and Seed Script

Generated by SeedDataAgent for smoke testing.
Run this before starting the app to ensure test resources exist.

Usage:
    python scripts/seed_db.py
"""
import asyncio
import os
import sys

# Add project root to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import structlog

logger = structlog.get_logger(__name__)


async def init_database():
    """Initialize database tables."""
    from src.core.database import init_db
    logger.info("ðŸ”„ Creating database tables (if not exists)...")
    try:
        await init_db()
        logger.info("âœ… Database tables created")
    except Exception as e:
        if "already exists" in str(e).lower():
            logger.info("â„¹ï¸ Tables already exist (alembic ran first)")
        else:
            raise


async def seed_test_data():
    """Seed minimal test data for smoke testing.

    Bug #143 Fix: Use direct session creation instead of get_db() generator.
    The generator pattern causes issues when exiting with 'break' - the
    generator cleanup code tries another commit which can trigger rollback.
    """
    from src.core.database import _get_session_maker

    logger.info("ðŸŒ± Seeding test data...")

    session_maker = _get_session_maker()
    async with session_maker() as session:
        try:
{seed_entries}
            await session.commit()
            logger.info("âœ… Test data seeded successfully")
        except Exception as e:
            await session.rollback()
            # Ignore duplicate key errors (data already exists)
            if "duplicate key" in str(e).lower() or "unique constraint" in str(e).lower():
                logger.info("â„¹ï¸ Test data already exists, skipping seed")
            else:
                logger.error(f"âŒ Failed to seed data: {{e}}")
                raise


async def main():
    """Initialize database and seed test data."""
    logger.info("ðŸš€ Starting database initialization...")

    try:
        await init_database()
        await seed_test_data()
        logger.info("âœ… Database initialization complete!")
    except Exception as e:
        logger.error(f"âŒ Database initialization failed: {{e}}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
'''


class SeedDataAgent:
    """
    Agent for generating seed_db.py from SmokeTestPlan.

    Deterministic: Generates code directly from plan without LLM for simple cases.
    Uses LLM only for complex field value generation.
    """

    def __init__(self, llm_client: Optional[EnhancedAnthropicClient] = None):
        self.llm = llm_client or EnhancedAnthropicClient()

    def generate_seed_script(
        self,
        plan: SmokeTestPlan,
        ir: ApplicationIR
    ) -> str:
        """
        Generate seed_db.py from SmokeTestPlan.

        Args:
            plan: SmokeTestPlan with seed_data
            ir: ApplicationIR for entity schema reference

        Returns:
            Complete seed_db.py script as string
        """
        logger.info("ðŸŒ± Seed Data Agent: Generating seed script from plan")

        # Sort entities by dependencies (topological sort)
        sorted_entities = self._sort_by_dependencies(plan.seed_data, ir)

        # Generate seed entries
        seed_entries = self._generate_seed_entries(sorted_entities, ir)

        # Fill template
        script = SEED_TEMPLATE.format(seed_entries=seed_entries)

        logger.info(f"   âœ… Generated seed script with {len(sorted_entities)} entities")

        return script

    def _sort_by_dependencies(
        self,
        entities: List[SeedDataEntity],
        ir: ApplicationIR
    ) -> List[SeedDataEntity]:
        """Sort entities so parents come before children (FK dependencies).

        Uses two sources of FK information (domain-agnostic):
        1. DomainModelIR.entities[].relationships (explicit)
        2. ValidationModelIR.get_fk_relationships() (inferred from RELATIONSHIP rules)
        """
        # Build dependency graph from IR relationships
        entity_deps: Dict[str, List[str]] = {}

        # Source 1: Explicit relationships from DomainModelIR
        for entity in ir.get_entities():
            deps = []
            for rel in entity.relationships:
                # many_to_one means this entity depends on target
                if rel.type.value == "many_to_one" or rel.type.name == "MANY_TO_ONE":
                    deps.append(rel.target_entity)
            entity_deps[entity.name] = deps

        # Source 2: FK relationships from ValidationModelIR (fallback/augmentation)
        if ir.validation_model:
            fk_rels = ir.validation_model.get_fk_relationships()
            for fk in fk_rels:
                child = fk["child_entity"]
                parent = fk["parent_entity"]
                if child not in entity_deps:
                    entity_deps[child] = []
                if parent not in entity_deps[child]:
                    entity_deps[child].append(parent)

        logger.debug(f"ðŸ”— Entity dependencies: {entity_deps}")

        # Map seed entities by name
        entity_map = {e.entity_name: e for e in entities}

        # Topological sort
        sorted_names: List[str] = []
        visited = set()
        temp_visited = set()

        def visit(name: str):
            if name in temp_visited:
                return  # Cycle, ignore
            if name in visited:
                return
            temp_visited.add(name)

            # Visit dependencies first
            for dep in entity_deps.get(name, []):
                if dep in entity_map:
                    visit(dep)

            temp_visited.remove(name)
            visited.add(name)
            sorted_names.append(name)

        for entity in entities:
            visit(entity.entity_name)

        # Return sorted entities
        return [entity_map[name] for name in sorted_names if name in entity_map]

    def _generate_seed_entries(
        self,
        entities: List[SeedDataEntity],
        ir: ApplicationIR
    ) -> str:
        """Generate Python code for each seed entity."""
        entries = []

        for entity in entities:
            entry = self._generate_entity_entry(entity, ir)
            entries.append(entry)

        return '\n'.join(entries)

    def _generate_entity_entry(
        self,
        entity: SeedDataEntity,
        ir: ApplicationIR
    ) -> str:
        """Generate Python code for a single entity.

        Phase 1.3: Uses IR constraints to generate valid field values
        when not explicitly provided.
        """
        entity_class = f"{entity.entity_name}Entity"
        var_name = f"test_{entity.entity_name.lower()}"

        # Build field assignments
        field_lines = [f"id=UUID(\"{entity.uuid}\")"]

        # Get entity schema from IR
        ir_entity = next(
            (e for e in ir.get_entities() if e.name == entity.entity_name),
            None
        )

        for field_name, field_value in entity.fields.items():
            # Phase 1.3: If value is None or empty, try to get from IR constraints
            if field_value is None or field_value == "":
                field_value = self._get_value_from_ir(entity.entity_name, field_name, ir)

            # Check if field is a FK (UUID type pointing to another entity)
            is_fk = False
            if ir_entity:
                for rel in ir_entity.relationships:
                    if rel.field_name == field_name:
                        is_fk = True
                        break

            # Format value
            if is_fk and isinstance(field_value, str) and self._looks_like_uuid(field_value):
                field_lines.append(f"{field_name}=UUID(\"{field_value}\")")
            elif isinstance(field_value, str):
                field_lines.append(f"{field_name}=\"{field_value}\"")
            elif isinstance(field_value, bool):
                field_lines.append(f"{field_name}={field_value}")
            elif isinstance(field_value, (int, float)):
                field_lines.append(f"{field_name}={field_value}")
            else:
                # For complex types, use repr
                field_lines.append(f"{field_name}={repr(field_value)}")

        fields_str = ",\n                ".join(field_lines)

        return f'''            # Seed {entity.entity_name} with predictable UUID for smoke testing
            from src.models.entities import {entity_class}
            from uuid import UUID
            {var_name} = {entity_class}(
                {fields_str}
            )
            session.add({var_name})
            logger.info("âœ… Created test {entity.entity_name} with ID {entity.uuid}")'''

    def _get_value_from_ir(self, entity_name: str, field_name: str, ir: ApplicationIR) -> Any:
        """Phase 1.3: Get valid value from IR constraints.

        Domain-agnostic value generation based on:
        1. ValidationModelIR constraints (min/max, enums, formats)
        2. DomainModelIR attribute defaults
        3. Generic fallbacks by type
        """
        import re

        # Try ValidationModelIR first
        if ir.validation_model:
            for rule in ir.validation_model.rules:
                if rule.entity == entity_name and rule.attribute == field_name:
                    condition = rule.condition or ""

                    # Enum values (STATUS_TRANSITION)
                    if "one of" in condition.lower():
                        values = re.findall(r'[A-Z_]+', condition.split("one of")[-1])
                        if values:
                            return values[0]  # Return first (initial state)

                    # Range constraints
                    if "min" in condition.lower() or "ge=" in condition:
                        try:
                            min_val = float(re.search(r'(?:min[:\s=]*|ge=)(\d+\.?\d*)', condition, re.I).group(1))
                            return min_val + 1  # Return min + 1
                        except:
                            pass

        # Try DomainModelIR defaults
        ir_entity = next((e for e in ir.get_entities() if e.name == entity_name), None)
        if ir_entity:
            for attr in ir_entity.attributes:
                if attr.name == field_name and attr.default_value is not None:
                    return attr.default_value

        # Type-based fallback (domain-agnostic)
        # Field type should be inferred from IR, not field name patterns
        ir_entity = next((e for e in ir.get_entities() if e.name == entity_name), None)
        if ir_entity:
            attr = next((a for a in ir_entity.attributes if a.name == field_name), None)
            if attr:
                type_lower = (attr.data_type or '').lower()
                if 'int' in type_lower or 'integer' in type_lower:
                    return 1
                if 'float' in type_lower or 'decimal' in type_lower:
                    return 1.0
                if 'bool' in type_lower:
                    return True
                if 'enum' in type_lower:
                    # Use first enum value from constraints
                    for constraint in (attr.constraints or []):
                        if 'values' in constraint.lower():
                            values = re.findall(r'[A-Z_]+', constraint)
                            if values:
                                return values[0]

        return "test_value"

    def _looks_like_uuid(self, value: str) -> bool:
        """Check if string looks like a UUID."""
        import re
        uuid_pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
        return bool(re.match(uuid_pattern, value, re.IGNORECASE))
