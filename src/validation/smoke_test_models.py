"""
Smoke Test Data Models

Phase 1 of Bug #107: LLM-Driven Smoke Test Generation
These models are used by all smoke test agents for consistent data flow.
"""
from dataclasses import dataclass, field, asdict
from typing import Dict, List, Optional, Union, Any
import json


@dataclass
class TestScenario:
    """Single test scenario for an endpoint."""
    endpoint: str                              # "GET /products/{id}"
    name: str                                  # "happy_path", "not_found"
    description: str = ""                      # Human-readable
    path_params: Dict[str, str] = field(default_factory=dict)
    query_params: Optional[Dict[str, str]] = None
    payload: Optional[Dict[str, Any]] = None
    expected_status: Union[int, List[int]] = 200
    expected_response_contains: Optional[List[str]] = None
    reason: Optional[str] = None               # Why this scenario was generated (for debugging)

    @property
    def method(self) -> str:
        """Extract HTTP method from endpoint string."""
        return self.endpoint.split()[0].upper()

    @property
    def path(self) -> str:
        """Extract path from endpoint string."""
        parts = self.endpoint.split(maxsplit=1)
        return parts[1] if len(parts) > 1 else ""


@dataclass
class SeedDataEntity:
    """Seed data for a single entity."""
    entity_name: str
    uuid: str
    fields: Dict[str, Any]
    depends_on: List[str] = field(default_factory=list)  # FK dependencies


@dataclass
class SmokeTestPlan:
    """Complete smoke test plan generated by PlannerAgent."""
    seed_data: List[SeedDataEntity]
    scenarios: List[TestScenario]

    def to_json(self) -> str:
        """Serialize to JSON string."""
        return json.dumps(asdict(self), indent=2)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)

    @classmethod
    def from_json(cls, data: str) -> 'SmokeTestPlan':
        """Deserialize from JSON string."""
        parsed = json.loads(data)
        return cls.from_dict(parsed)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SmokeTestPlan':
        """Create from dictionary."""
        return cls(
            seed_data=[SeedDataEntity(**e) for e in data.get('seed_data', [])],
            scenarios=[TestScenario(**s) for s in data.get('scenarios', [])]
        )

    def get_scenarios_for_endpoint(self, method: str, path: str) -> List[TestScenario]:
        """Get all scenarios for a specific endpoint."""
        endpoint_key = f"{method.upper()} {path}"
        return [s for s in self.scenarios if s.endpoint == endpoint_key]

    def get_happy_path_scenarios(self) -> List[TestScenario]:
        """Get all happy path scenarios."""
        return [s for s in self.scenarios if s.name == "happy_path"]

    def get_error_scenarios(self) -> List[TestScenario]:
        """Get all error scenarios (not_found, validation_error, etc.)."""
        return [s for s in self.scenarios if s.name != "happy_path"]


@dataclass
class ScenarioResult:
    """Result of executing a single scenario."""
    scenario: TestScenario
    actual_status: Optional[int] = None
    response_body: Optional[str] = None
    response_time_ms: float = 0
    status_matches: bool = False
    error: Optional[str] = None

    @property
    def success(self) -> bool:
        """Alias for status_matches for clarity."""
        return self.status_matches

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for reporting."""
        return {
            "endpoint": self.scenario.endpoint,
            "scenario_name": self.scenario.name,
            "expected_status": self.scenario.expected_status,
            "actual_status": self.actual_status,
            "success": self.success,
            "response_time_ms": self.response_time_ms,
            "error": self.error
        }


@dataclass
class TestMetrics:
    """Aggregated test metrics."""
    total: int = 0
    passed: int = 0
    failed: int = 0
    happy_path_passed: int = 0
    happy_path_total: int = 0
    avg_response_time_ms: float = 0.0

    @classmethod
    def from_results(cls, results: List[ScenarioResult]) -> 'TestMetrics':
        """Calculate metrics from a list of results."""
        if not results:
            return cls()

        happy_path_results = [r for r in results if r.scenario.name == "happy_path"]

        return cls(
            total=len(results),
            passed=sum(1 for r in results if r.success),
            failed=sum(1 for r in results if not r.success),
            happy_path_passed=sum(1 for r in happy_path_results if r.success),
            happy_path_total=len(happy_path_results),
            avg_response_time_ms=sum(r.response_time_ms for r in results) / len(results)
        )

    @property
    def pass_rate(self) -> float:
        """Calculate pass rate as percentage."""
        return (self.passed / self.total * 100) if self.total > 0 else 0.0

    @property
    def happy_path_pass_rate(self) -> float:
        """Calculate happy path pass rate as percentage."""
        return (self.happy_path_passed / self.happy_path_total * 100) if self.happy_path_total > 0 else 0.0


@dataclass
class SmokeTestReport:
    """Final report from ValidationAgent."""
    metrics: TestMetrics
    status: str  # "PASSED" | "FAILED"
    summary: str
    failures: List[ScenarioResult] = field(default_factory=list)
    analysis: Optional[str] = None
    recommendations: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "status": self.status,
            "summary": self.summary,
            "metrics": {
                "total": self.metrics.total,
                "passed": self.metrics.passed,
                "failed": self.metrics.failed,
                "pass_rate": f"{self.metrics.pass_rate:.1f}%",
                "happy_path_passed": self.metrics.happy_path_passed,
                "happy_path_total": self.metrics.happy_path_total,
                "avg_response_time_ms": f"{self.metrics.avg_response_time_ms:.2f}"
            },
            "failures": [f.to_dict() for f in self.failures],
            "analysis": self.analysis,
            "recommendations": self.recommendations
        }

    def to_json(self) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=2)
