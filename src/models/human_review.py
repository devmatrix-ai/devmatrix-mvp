"""
Human Review Queue Database Model

SQLAlchemy ORM model for MGE V2 human review queue.

HumanReviewQueue: Low-confidence atoms flagged for human review

Schema design based on MGE V2 specification.
"""

import uuid
from datetime import datetime
from typing import Optional, Dict
from sqlalchemy import (
    Column, String, Text, Integer, Float, DateTime, ForeignKey, Enum, Index
)
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID, JSONB
import enum

from src.config.database import Base


# Enums
class ReviewStatus(str, enum.Enum):
    """Human review status"""
    PENDING = "pending"          # Awaiting review
    IN_REVIEW = "in_review"      # Currently being reviewed
    APPROVED = "approved"        # Approved by reviewer
    REJECTED = "rejected"        # Rejected by reviewer
    EDITED = "edited"            # Edited by reviewer
    REGENERATED = "regenerated"  # Regenerated by system


class ReviewResolution(str, enum.Enum):
    """Review resolution actions"""
    APPROVE = "approve"          # Accept as-is
    EDIT = "edit"                # Human-edited version
    REGENERATE = "regenerate"    # Regenerate with AI
    SKIP = "skip"                # Skip for now


class HumanReviewQueue(Base):
    """
    Human Review Queue - Low-confidence atom review

    MGE V2 review strategy:
    - Bottom 15-20% by confidence score flagged for review
    - Confidence calculation:
      - Validation results (40%)
      - Attempts needed (30%)
      - Complexity (20%)
      - Integration tests (10%)
    - AI-generated fix suggestions
    - Priority ranking (1=critical, 5=low)

    Review actions:
    - Approve: Accept atom as-is
    - Edit: Human-edited code
    - Regenerate: Request AI regeneration
    - Skip: Skip review (use as-is)
    """
    __tablename__ = "human_review_queue"

    # Primary Key
    review_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Foreign Keys
    atom_id = Column(UUID(as_uuid=True), ForeignKey("atomic_units.atom_id", ondelete="CASCADE"), nullable=False)
    assigned_to = Column(UUID(as_uuid=True), ForeignKey("users.user_id", ondelete="SET NULL"), nullable=True)

    # Review Info
    confidence_score = Column(Float, nullable=False, index=True)  # Why flagged (<0.85)
    flagged_reason = Column(Text, nullable=True)  # Specific issues detected
    ai_suggestions = Column(JSONB, nullable=True)  # AI-generated fixes:
    # {
    #   "issues": ["issue1", "issue2"],
    #   "suggestions": [
    #     {"type": "fix", "description": "...", "code": "..."},
    #     {"type": "alternative", "description": "...", "code": "..."}
    #   ],
    #   "quality_scores": [0.8, 0.9]
    # }

    # Priority (1=critical, 5=low)
    priority = Column(Integer, nullable=False, default=5, index=True)

    # Review Status
    status = Column(Enum(ReviewStatus), nullable=False, default=ReviewStatus.PENDING, index=True)

    # Review Outcome
    resolution = Column(Enum(ReviewResolution), nullable=True)  # How was it resolved
    reviewer_feedback = Column(Text, nullable=True)  # Reviewer comments
    edited_code = Column(Text, nullable=True)  # Human-edited version

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    assigned_at = Column(DateTime, nullable=True)
    reviewed_at = Column(DateTime, nullable=True)

    # Relationships
    atom = relationship("AtomicUnit", back_populates="review")
    reviewer = relationship("User", foreign_keys=[assigned_to])

    # Indexes
    __table_args__ = (
        Index("idx_review_atom", "atom_id"),
        Index("idx_review_status", "status"),
        Index("idx_review_priority", "priority"),
        Index("idx_review_assigned", "assigned_to"),
        Index("idx_review_confidence", "confidence_score"),
        Index("idx_review_status_priority", "status", "priority"),  # Composite for queue queries
    )

    def __repr__(self) -> str:
        return f"<HumanReviewQueue(review_id={self.review_id}, atom_id={self.atom_id}, priority={self.priority}, status={self.status})>"

    def to_dict(self) -> Dict:
        """Convert to dictionary for API responses"""
        return {
            "review_id": str(self.review_id),
            "atom_id": str(self.atom_id),
            "confidence_score": self.confidence_score,
            "flagged_reason": self.flagged_reason,
            "ai_suggestions": self.ai_suggestions,
            "priority": self.priority,
            "status": self.status.value,
            "resolution": self.resolution.value if self.resolution else None,
            "reviewer_feedback": self.reviewer_feedback,
            "assigned_to": str(self.assigned_to) if self.assigned_to else None,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "assigned_at": self.assigned_at.isoformat() if self.assigned_at else None,
            "reviewed_at": self.reviewed_at.isoformat() if self.reviewed_at else None,
        }

    @property
    def time_in_queue_hours(self) -> Optional[float]:
        """Calculate time in queue (hours)"""
        if self.reviewed_at:
            delta = self.reviewed_at - self.created_at
        else:
            delta = datetime.utcnow() - self.created_at
        return delta.total_seconds() / 3600.0
