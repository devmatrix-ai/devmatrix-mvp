"""
Stateful Workflow - LangGraph workflow with Redis + PostgreSQL persistence

This workflow demonstrates:
- Redis for temporary workflow state
- PostgreSQL for persistent task tracking
- Cost tracking integration
- Error handling and recovery
"""

from typing import Any
from src.observability import get_logger
from uuid import uuid4, UUID
from datetime import datetime

from langgraph.graph import StateGraph, END
from src.state.graph_state import AgentState
from src.state.redis_manager import RedisManager
from src.state.postgres_manager import PostgresManager


class StatefulWorkflow:
    """
    Workflow with integrated state persistence.

    Manages workflow state in Redis and task history in PostgreSQL.
    """

    def __init__(
        self,
        redis_manager: RedisManager = None,
        postgres_manager: PostgresManager = None,
    ):
        """
        Initialize stateful workflow.

        Args:
            redis_manager: Redis manager instance (creates new if None)
            postgres_manager: PostgreSQL manager instance (creates new if None)
        """
        self.redis = redis_manager or RedisManager()
        self.postgres = postgres_manager or PostgresManager()

    def create_agent_node(self, agent_name: str):
        """
        Create an agent node with state persistence.

        Args:
            agent_name: Name of the agent

        Returns:
            Agent node function with persistence
        """

        def agent_node_with_persistence(state: AgentState) -> dict[str, Any]:
            """
            Agent node that saves state to Redis and tracks execution in PostgreSQL.
            """
            workflow_id = state.get("workflow_id")
            project_id = state.get("project_id")

            # Save current state to Redis
            self.redis.save_workflow_state(workflow_id, dict(state))

            # Get or create task in PostgreSQL
            task_id_str = state.get("task_id")
            if not task_id_str or task_id_str == "":
                self.logger.debug("Project ID from state", project_id=project_id, project_id_type=type(project_id).__name__)
                project_uuid = UUID(project_id) if project_id else uuid4()
                self.logger.debug("Project UUID", project_uuid=str(project_uuid), project_uuid_type=type(project_uuid).__name__)

                task_id = self.postgres.create_task(
                    project_id=project_uuid,
                    agent_name=agent_name,
                    task_type="greeting",
                    input_data={"user_request": state.get("user_request", "")},
                )
            else:
                task_id = UUID(task_id_str)

            # Update task status to in_progress
            self.postgres.update_task_status(
                task_id=task_id, status="in_progress", output_data=None
            )

            # Agent logic (simple greeting for now)
            user_request = state.get("user_request", "")
            greeting = f"[{agent_name}] Processing your request: '{user_request}'"

            message = {
                "role": "assistant",
                "content": greeting,
                "agent": agent_name,
                "workflow_id": workflow_id,
                "timestamp": datetime.now().isoformat(),
            }

            generated_code = f"# Code generated by {agent_name}\n# Request: {user_request}\n"

            # Mark task as completed
            self.postgres.update_task_status(
                task_id=task_id,
                status="completed",
                output_data={
                    "message": message,
                    "generated_code": generated_code,
                },
            )

            # Return state updates
            return {
                "messages": [message],
                "current_task": f"{agent_name}_complete",
                "agent_name": agent_name,
                "generated_code": generated_code,
                "task_id": str(task_id),
            }

        return agent_node_with_persistence

    def create_workflow(self) -> StateGraph:
        """
        Create a stateful workflow with persistence.

        Returns:
            Compiled LangGraph workflow
        """
        # Create workflow
        workflow = StateGraph(AgentState)

        # Add node with persistence
        stateful_agent = self.create_agent_node("stateful_agent")
        workflow.add_node("stateful_agent", stateful_agent)

        # Define flow
        workflow.set_entry_point("stateful_agent")
        workflow.add_edge("stateful_agent", END)

        return workflow.compile()

    def run_workflow(
        self,
        user_request: str,
        project_name: str = "Demo Project",
        project_description: str = "",
    ) -> tuple[AgentState, UUID, UUID]:
        """
        Execute stateful workflow.

        Args:
            user_request: User's request
            project_name: Project name
            project_description: Project description

        Returns:
            Tuple of (final_state, project_id, task_id)
        """
        # Create project in PostgreSQL
        project_id = self.postgres.create_project(
            name=project_name, description=project_description
        )

        self.logger.debug("Created project ID", project_id=project_id, project_id_type=type(project_id).__name__)

        # Generate workflow ID
        workflow_id = str(uuid4())

        # Initialize state
        initial_state: AgentState = {
            "user_request": user_request,
            "messages": [],
            "current_task": "starting",
            "generated_code": "",
            "workflow_id": workflow_id,
            "project_id": str(project_id),
            "agent_name": "",
            "error": None,
            "retry_count": 0,
            "task_id": "",
        }

        # Save initial state to Redis
        self.redis.save_workflow_state(workflow_id, initial_state)

        # Execute workflow
        app = self.create_workflow()
        final_state = app.invoke(initial_state)

        # Retrieve task_id from final state
        task_id = UUID(final_state["task_id"])

        return final_state, project_id, task_id

    def get_workflow_state_from_redis(self, workflow_id: str) -> dict | None:
        """
        Retrieve workflow state from Redis.

        Args:
            workflow_id: Workflow UUID

        Returns:
            State dict if found, None otherwise
        """
        return self.redis.get_workflow_state(workflow_id)

    def get_task_from_postgres(self, task_id: UUID) -> dict | None:
        """
        Retrieve task from PostgreSQL.

        Args:
            task_id: Task UUID

        Returns:
            Task dict if found, None otherwise
        """
        return self.postgres.get_task(task_id)

    def track_llm_cost(
        self,
        task_id: UUID,
        model_name: str,
        input_tokens: int,
        output_tokens: int,
        cost_usd: float,
    ) -> UUID:
        """
        Track LLM cost for a task.

        Args:
            task_id: Task UUID
            model_name: Model name
            input_tokens: Input tokens
            output_tokens: Output tokens
            cost_usd: Cost in USD

        Returns:
            Cost tracking UUID
        """
        return self.postgres.track_cost(
            task_id=task_id,
            model_name=model_name,
            input_tokens=input_tokens,
            output_tokens=output_tokens,
            cost_usd=cost_usd,
        )

    def close(self):
        """Close all connections."""
        self.redis.close()
        self.postgres.close()
