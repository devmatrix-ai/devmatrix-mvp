"""
Repository Pattern Implementation

Database access layer with CRUD operations.
"""
from typing import List, Optional, Any, Dict
from uuid import UUID
from sqlalchemy import select, delete, func, or_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
import structlog
{% for entity in entities %}
from src.models.entities import {{ entity.name }}Entity
from src.models.schemas import {{ entity.name }}Create, {{ entity.name }}Update
{% endfor %}

logger = structlog.get_logger(__name__)


class BaseRepository:
    """Base repository with common CRUD operations."""

    def __init__(self, db: AsyncSession, model):
        self.db = db
        self.model = model

    async def create(self, data: dict) -> Any:
        """Create a new record."""
        try:
            db_obj = self.model(**data)
            self.db.add(db_obj)
            await self.db.commit()
            await self.db.refresh(db_obj)
            return db_obj
        except IntegrityError as e:
            await self.db.rollback()
            logger.error(f"Integrity error creating {self.model.__name__}", error=str(e))
            raise

    async def get(self, id: UUID) -> Optional[Any]:
        """Get a single record by ID."""
        result = await self.db.execute(
            select(self.model).where(self.model.id == id)
        )
        return result.scalar_one_or_none()

    async def list(self, skip: int = 0, limit: int = 100) -> List[Any]:
        """List records with pagination."""
        result = await self.db.execute(
            select(self.model)
            .offset(skip)
            .limit(limit)
            .order_by(self.model.created_at.desc())
        )
        return result.scalars().all()

    async def update(self, id: UUID, data: dict) -> Optional[Any]:
        """Update a record."""
        db_obj = await self.get(id)
        if not db_obj:
            return None

        for key, value in data.items():
            if value is not None:
                setattr(db_obj, key, value)

        await self.db.commit()
        await self.db.refresh(db_obj)
        return db_obj

    async def delete(self, id: UUID) -> bool:
        """Delete a record."""
        result = await self.db.execute(
            delete(self.model).where(self.model.id == id)
        )
        await self.db.commit()
        return result.rowcount > 0

    async def count(self) -> int:
        """Count total records."""
        result = await self.db.execute(
            select(func.count()).select_from(self.model)
        )
        return result.scalar() or 0

    async def exists(self, id: UUID) -> bool:
        """Check if record exists."""
        result = await self.db.execute(
            select(func.count()).select_from(self.model).where(self.model.id == id)
        )
        return (result.scalar() or 0) > 0

{% for entity in entities %}

class {{ entity.name }}Repository(BaseRepository):
    """Repository for {{ entity.name }} entity."""

    def __init__(self, db: AsyncSession):
        super().__init__(db, {{ entity.name }}Entity)

    {%- if 'email' in entity.fields | map(attribute='name') %}

    async def get_by_email(self, email: str) -> Optional[{{ entity.name }}Entity]:
        """Get {{ entity.name | lower }} by email."""
        result = await self.db.execute(
            select(self.model).where(self.model.email == email)
        )
        return result.scalar_one_or_none()
    {%- endif %}

    {%- if 'name' in entity.fields | map(attribute='name') %}

    async def search_by_name(self, query: str) -> List[{{ entity.name }}Entity]:
        """Search {{ entity.plural | lower }} by name."""
        result = await self.db.execute(
            select(self.model).where(
                self.model.name.ilike(f"%{query}%")
            ).limit(10)
        )
        return result.scalars().all()
    {%- endif %}

    {%- if 'status' in entity.fields | map(attribute='name') %}

    async def get_by_status(self, status: str) -> List[{{ entity.name }}Entity]:
        """Get {{ entity.plural | lower }} by status."""
        result = await self.db.execute(
            select(self.model).where(self.model.status == status)
        )
        return result.scalars().all()
    {%- endif %}

    async def create_{{ entity.name | lower }}(self, data: {{ entity.name }}Create) -> {{ entity.name }}Entity:
        """Create a new {{ entity.name | lower }}."""
        return await self.create(data.model_dump())

    async def update_{{ entity.name | lower }}(self, id: UUID, data: {{ entity.name }}Update) -> Optional[{{ entity.name }}Entity]:
        """Update a {{ entity.name | lower }}."""
        return await self.update(id, data.model_dump(exclude_unset=True))
{% endfor %}