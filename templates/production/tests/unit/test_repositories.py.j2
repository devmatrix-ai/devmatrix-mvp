"""
Unit tests for {{ app_name }} repository layer.

Tests CRUD operations with mocked database sessions.
"""

import pytest
from unittest.mock import Mock, MagicMock, patch, call
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, SQLAlchemyError

from repositories.repository import (
    {% for entity in entities %}{{ entity.name }}Repository,
    {% endfor %}
)
from models.entities import (
    {% for entity in entities %}{{ entity.name }},
    {% endfor %}
)
from models.schemas import (
    {% for entity in entities %}{{ entity.name }}Create,
    {{ entity.name }}Update,
    {% endfor %}
)

{% for entity in entities %}
class Test{{ entity.name }}Repository:
    """Test suite for {{ entity.name }}Repository."""

    @pytest.fixture
    def mock_db(self):
        """Create a mock database session."""
        return MagicMock(spec=Session)

    @pytest.fixture
    def repository(self, mock_db):
        """Create repository instance with mock database."""
        return {{ entity.name }}Repository(mock_db)

    @pytest.fixture
    def sample_entity(self):
        """Create a sample {{ entity.name }} entity."""
        entity = {{ entity.name }}()
        entity.id = 1
        {% for field in entity.fields %}
        {% if field.type == "str" %}
        entity.{{ field.name }} = "test_value"
        {% elif field.type == "int" %}
        entity.{{ field.name }} = 42
        {% elif field.type == "float" %}
        entity.{{ field.name }} = 3.14
        {% elif field.type == "bool" %}
        entity.{{ field.name }} = True
        {% elif field.type == "datetime" %}
        entity.{{ field.name }} = datetime.now(timezone.utc)
        {% elif field.type in ["json", "dict"] %}
        entity.{{ field.name }} = {"key": "value"}
        {% elif field.type == "list" %}
        entity.{{ field.name }} = ["item1", "item2"]
        {% endif %}
        {% endfor %}
        return entity

    # Test CREATE operations
    def test_create_success(self, repository, mock_db, sample_entity):
        """Test successful entity creation."""
        create_data = {{ entity.name }}Create(
            {% for field in entity.fields if field.name != "id" %}
            {% if field.type == "str" %}
            {{ field.name }}="new_value",
            {% elif field.type == "int" %}
            {{ field.name }}=100,
            {% elif field.type == "float" %}
            {{ field.name }}=99.99,
            {% elif field.type == "bool" %}
            {{ field.name }}=False,
            {% endif %}
            {% endfor %}
        )

        mock_db.add.return_value = None
        mock_db.commit.return_value = None
        mock_db.refresh.return_value = None

        # Mock the created entity
        def set_id(entity):
            entity.id = 1
        mock_db.refresh.side_effect = set_id

        result = repository.create(create_data)

        mock_db.add.assert_called_once()
        mock_db.commit.assert_called_once()
        mock_db.refresh.assert_called_once()

        # Verify the entity was created with correct data
        created_entity = mock_db.add.call_args[0][0]
        {% for field in entity.fields if field.name != "id" %}
        {% if field.type in ["str", "int", "float", "bool"] %}
        assert created_entity.{{ field.name }} == create_data.{{ field.name }}
        {% endif %}
        {% endfor %}

    def test_create_database_error(self, repository, mock_db):
        """Test creation with database error."""
        create_data = {{ entity.name }}Create(
            {% for field in entity.fields if field.name != "id" %}
            {% if field.type == "str" %}
            {{ field.name }}="value",
            {% elif field.type == "int" %}
            {{ field.name }}=1,
            {% endif %}
            {% endfor %}
        )

        mock_db.commit.side_effect = SQLAlchemyError("Database error")

        with pytest.raises(SQLAlchemyError):
            repository.create(create_data)

        mock_db.rollback.assert_called_once()

    def test_create_integrity_error(self, repository, mock_db):
        """Test creation with integrity constraint violation."""
        create_data = {{ entity.name }}Create(
            {% for field in entity.fields if field.name != "id" %}
            {% if field.type == "str" %}
            {{ field.name }}="duplicate_value",
            {% elif field.type == "int" %}
            {{ field.name }}=1,
            {% endif %}
            {% endfor %}
        )

        mock_db.commit.side_effect = IntegrityError("Duplicate key", None, None)

        with pytest.raises(IntegrityError):
            repository.create(create_data)

        mock_db.rollback.assert_called_once()

    # Test READ operations
    def test_get_by_id_found(self, repository, mock_db, sample_entity):
        """Test getting entity by ID when it exists."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = sample_entity

        result = repository.get(1)

        assert result == sample_entity
        assert result.id == 1
        mock_db.query.assert_called_with({{ entity.name }})

    def test_get_by_id_not_found(self, repository, mock_db):
        """Test getting entity by ID when it doesn't exist."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = None

        result = repository.get(999)

        assert result is None

    def test_get_all_no_filters(self, repository, mock_db, sample_entity):
        """Test getting all entities without filters."""
        entities = [sample_entity, sample_entity]
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.offset.return_value = mock_query
        mock_query.limit.return_value = mock_query
        mock_query.all.return_value = entities

        result = repository.get_all(skip=0, limit=10)

        assert len(result) == 2
        mock_query.offset.assert_called_with(0)
        mock_query.limit.assert_called_with(10)

    def test_get_all_with_filters(self, repository, mock_db, sample_entity):
        """Test getting all entities with filters."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.offset.return_value = mock_query
        mock_query.limit.return_value = mock_query
        mock_query.all.return_value = [sample_entity]

        filters = {
            {% for field in entity.fields[:2] %}
            {% if field.type == "str" %}
            "{{ field.name }}": "filter_value",
            {% elif field.type == "int" %}
            "{{ field.name }}": 10,
            {% endif %}
            {% endfor %}
        }

        result = repository.get_all(skip=0, limit=10, **filters)

        assert len(result) == 1
        # Verify filters were applied
        assert mock_query.filter.called

    def test_get_all_pagination(self, repository, mock_db):
        """Test pagination in get_all."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.offset.return_value = mock_query
        mock_query.limit.return_value = mock_query
        mock_query.all.return_value = []

        repository.get_all(skip=20, limit=5)

        mock_query.offset.assert_called_with(20)
        mock_query.limit.assert_called_with(5)

    # Test UPDATE operations
    def test_update_success(self, repository, mock_db, sample_entity):
        """Test successful entity update."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = sample_entity

        update_data = {{ entity.name }}Update(
            {% for field in entity.fields[:2] if field.name != "id" %}
            {% if field.type == "str" %}
            {{ field.name }}="updated_value",
            {% elif field.type == "int" %}
            {{ field.name }}=999,
            {% endif %}
            {% endfor %}
        )

        result = repository.update(1, update_data)

        assert result == sample_entity
        mock_db.commit.assert_called_once()
        mock_db.refresh.assert_called_once_with(sample_entity)

        # Verify updates were applied
        update_dict = update_data.model_dump(exclude_unset=True)
        for key, value in update_dict.items():
            assert getattr(sample_entity, key) == value

    def test_update_not_found(self, repository, mock_db):
        """Test updating non-existent entity."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = None

        update_data = {{ entity.name }}Update(
            {% for field in entity.fields[:1] if field.name != "id" %}
            {% if field.type == "str" %}
            {{ field.name }}="updated_value"
            {% elif field.type == "int" %}
            {{ field.name }}=999
            {% endif %}
            {% endfor %}
        )

        result = repository.update(999, update_data)

        assert result is None
        mock_db.commit.assert_not_called()

    def test_update_database_error(self, repository, mock_db, sample_entity):
        """Test update with database error."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = sample_entity

        update_data = {{ entity.name }}Update(
            {% for field in entity.fields[:1] if field.name != "id" %}
            {% if field.type == "str" %}
            {{ field.name }}="error_value"
            {% elif field.type == "int" %}
            {{ field.name }}=666
            {% endif %}
            {% endfor %}
        )

        mock_db.commit.side_effect = SQLAlchemyError("Update failed")

        with pytest.raises(SQLAlchemyError):
            repository.update(1, update_data)

        mock_db.rollback.assert_called_once()

    # Test DELETE operations
    def test_delete_success(self, repository, mock_db, sample_entity):
        """Test successful entity deletion."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = sample_entity

        result = repository.delete(1)

        assert result is True
        mock_db.delete.assert_called_once_with(sample_entity)
        mock_db.commit.assert_called_once()

    def test_delete_not_found(self, repository, mock_db):
        """Test deleting non-existent entity."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = None

        result = repository.delete(999)

        assert result is False
        mock_db.delete.assert_not_called()
        mock_db.commit.assert_not_called()

    def test_delete_database_error(self, repository, mock_db, sample_entity):
        """Test deletion with database error."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.first.return_value = sample_entity

        mock_db.commit.side_effect = SQLAlchemyError("Delete failed")

        with pytest.raises(SQLAlchemyError):
            repository.delete(1)

        mock_db.rollback.assert_called_once()

    # Test batch operations
    def test_create_batch(self, repository, mock_db):
        """Test batch creation of entities."""
        create_items = [
            {{ entity.name }}Create(
                {% for field in entity.fields[:1] if field.name != "id" %}
                {% if field.type == "str" %}
                {{ field.name }}=f"batch_value_{i}"
                {% elif field.type == "int" %}
                {{ field.name }}=i
                {% endif %}
                {% endfor %}
            )
            for i in range(3)
        ]

        mock_db.bulk_insert_mappings = MagicMock()
        mock_db.commit.return_value = None

        repository.create_batch(create_items)

        assert mock_db.bulk_insert_mappings.called or mock_db.add_all.called
        mock_db.commit.assert_called_once()

    def test_delete_batch(self, repository, mock_db):
        """Test batch deletion of entities."""
        ids = [1, 2, 3]
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.delete.return_value = 3

        result = repository.delete_batch(ids)

        assert result == 3
        mock_db.commit.assert_called_once()

    # Test custom queries
    def test_custom_query_execution(self, repository, mock_db):
        """Test execution of custom queries."""
        mock_query = MagicMock()
        mock_db.query.return_value = mock_query
        mock_query.filter.return_value = mock_query
        mock_query.order_by.return_value = mock_query
        mock_query.all.return_value = []

        # Test custom filtering and ordering
        repository.get_by_custom_criteria(
            {% for field in entity.fields[:1] %}
            {% if field.type == "str" %}
            {{ field.name }}="custom_value"
            {% elif field.type == "int" %}
            {{ field.name }}=42
            {% endif %}
            {% endfor %}
        )

        assert mock_query.filter.called

    # Test transaction management
    def test_transaction_rollback_on_error(self, repository, mock_db):
        """Test that transactions are rolled back on error."""
        create_data = {{ entity.name }}Create(
            {% for field in entity.fields[:1] if field.name != "id" %}
            {% if field.type == "str" %}
            {{ field.name }}="transaction_test"
            {% elif field.type == "int" %}
            {{ field.name }}=1
            {% endif %}
            {% endfor %}
        )

        mock_db.commit.side_effect = [SQLAlchemyError("Transaction failed")]

        with pytest.raises(SQLAlchemyError):
            repository.create(create_data)

        mock_db.rollback.assert_called()

    def test_connection_pool_handling(self, repository, mock_db):
        """Test proper handling of connection pool."""
        mock_db.close.return_value = None

        # Simulate connection cleanup
        repository.cleanup()

        mock_db.close.assert_called_once()

{% endfor %}

# Test repository base class functionality
class TestRepositoryBase:
    """Test common repository functionality."""

    def test_repository_inheritance(self):
        """Test that all repositories inherit from base class."""
        {% for entity in entities %}
        assert hasattr({{ entity.name }}Repository, 'create')
        assert hasattr({{ entity.name }}Repository, 'get')
        assert hasattr({{ entity.name }}Repository, 'get_all')
        assert hasattr({{ entity.name }}Repository, 'update')
        assert hasattr({{ entity.name }}Repository, 'delete')
        {% endfor %}

    def test_repository_session_management(self):
        """Test database session management across repositories."""
        mock_db = MagicMock(spec=Session)

        {% for entity in entities %}
        repo = {{ entity.name }}Repository(mock_db)
        assert repo.db == mock_db
        {% endfor %}