"""
Tests for {{ app_name }} observability infrastructure.

Tests logging, metrics collection, distributed tracing, and health checks.
"""

import pytest
import json
import time
from unittest.mock import Mock, MagicMock, patch, call
from datetime import datetime, timedelta
import logging
from prometheus_client import CollectorRegistry, Counter, Histogram, Gauge
from opentelemetry import trace
from opentelemetry.trace import Status, StatusCode
import structlog

from core.logging import setup_logging, get_logger, LoggerAdapter
from core.metrics import (
    setup_metrics,
    track_request,
    track_error,
    track_business_metric,
    get_metrics_registry,
)
from api.health import get_health_status, HealthCheck, HealthStatus
from api.metrics import metrics_endpoint

class TestLogging:
    """Test logging infrastructure."""

    @pytest.fixture
    def logger(self):
        """Create a test logger."""
        return get_logger("{{ service_name }}.test")

    def test_structured_logging_setup(self):
        """Test that structured logging is properly configured."""
        logger = setup_logging("{{ app_name }}", environment="test")

        assert logger is not None
        assert isinstance(logger, (structlog.BoundLogger, logging.Logger))

    def test_log_context_injection(self, logger):
        """Test context injection in logs."""
        with patch('structlog.get_logger') as mock_get_logger:
            mock_logger = MagicMock()
            mock_get_logger.return_value = mock_logger

            # Log with context
            logger.info(
                "test_message",
                user_id=123,
                request_id="req-456",
                extra_field="value"
            )

            mock_logger.info.assert_called_once()
            call_args = mock_logger.info.call_args
            assert "user_id" in call_args[1]
            assert call_args[1]["user_id"] == 123
            assert call_args[1]["request_id"] == "req-456"

    def test_log_levels(self, logger):
        """Test all log levels work correctly."""
        with patch.object(logger, '_log') as mock_log:
            logger.debug("debug message")
            logger.info("info message")
            logger.warning("warning message")
            logger.error("error message")
            logger.critical("critical message")

            assert mock_log.call_count == 5

    def test_exception_logging(self, logger):
        """Test exception logging with stack traces."""
        try:
            raise ValueError("Test exception")
        except ValueError:
            logger.exception("Error occurred", exc_info=True)

        # Verify exception info was captured
        with patch.object(logger, 'error') as mock_error:
            try:
                raise ValueError("Test exception")
            except ValueError:
                logger.exception("Error occurred")

            mock_error.assert_called_once()
            assert "Error occurred" in str(mock_error.call_args)

    def test_correlation_id_propagation(self, logger):
        """Test correlation ID propagation across log entries."""
        correlation_id = "corr-123-456"

        with patch('structlog.contextvars.bind_contextvars') as mock_bind:
            logger.bind(correlation_id=correlation_id)
            logger.info("First message")
            logger.info("Second message")

            mock_bind.assert_called_with(correlation_id=correlation_id)

    def test_log_formatting(self, logger):
        """Test log output formatting."""
        with patch('sys.stdout') as mock_stdout:
            logger.info(
                "formatted_message",
                timestamp=datetime.utcnow().isoformat(),
                level="INFO",
                service="{{ service_name }}"
            )

            # Verify JSON formatting if configured
            if hasattr(logger, 'handlers'):
                for handler in logger.handlers:
                    if hasattr(handler.formatter, 'format'):
                        formatted = handler.formatter.format(None)
                        assert isinstance(json.loads(formatted), dict)

    def test_log_rotation(self):
        """Test log rotation configuration."""
        with patch('logging.handlers.RotatingFileHandler') as mock_handler:
            setup_logging(
                "{{ app_name }}",
                log_file="/tmp/test.log",
                max_bytes=10485760,  # 10MB
                backup_count=5
            )

            mock_handler.assert_called()
            call_args = mock_handler.call_args
            assert call_args[1]["maxBytes"] == 10485760
            assert call_args[1]["backupCount"] == 5

class TestMetrics:
    """Test metrics collection."""

    @pytest.fixture
    def registry(self):
        """Create a test metrics registry."""
        return CollectorRegistry()

    @pytest.fixture
    def metrics(self, registry):
        """Setup test metrics."""
        return setup_metrics("{{ service_name }}", registry=registry)

    def test_metrics_setup(self, metrics):
        """Test metrics initialization."""
        assert metrics is not None
        assert "http_requests_total" in metrics
        assert "http_request_duration_seconds" in metrics
        assert "business_events_total" in metrics

    def test_request_counter(self, metrics, registry):
        """Test HTTP request counting."""
        track_request(
            method="GET",
            endpoint="/api/{{ app_name }}/entity",
            status_code=200,
            duration=0.125
        )

        # Verify counter was incremented
        samples = list(registry.collect())
        request_metrics = [s for s in samples if "http_requests_total" in s.name]
        assert len(request_metrics) > 0

    def test_request_duration_histogram(self, metrics, registry):
        """Test request duration tracking."""
        durations = [0.01, 0.025, 0.1, 0.5, 1.0]

        for duration in durations:
            track_request(
                method="POST",
                endpoint="/api/{{ app_name }}/entity",
                status_code=201,
                duration=duration
            )

        samples = list(registry.collect())
        duration_metrics = [s for s in samples if "duration" in s.name]
        assert len(duration_metrics) > 0

    def test_error_counter(self, metrics, registry):
        """Test error counting by type."""
        error_types = [
            ("ValidationError", "validation"),
            ("DatabaseError", "database"),
            ("ExternalAPIError", "external"),
            ("BusinessRuleError", "business"),
        ]

        for error_type, category in error_types:
            track_error(
                error_type=error_type,
                category=category,
                endpoint="/api/{{ app_name }}/entity"
            )

        samples = list(registry.collect())
        error_metrics = [s for s in samples if "errors_total" in s.name]
        assert len(error_metrics) > 0

    def test_business_metrics(self, metrics, registry):
        """Test business-specific metrics."""
        # Track various business events
        track_business_metric("user_signup", {"plan": "premium"})
        track_business_metric("payment_processed", {"amount": 99.99, "currency": "USD"})
        track_business_metric("feature_usage", {"feature": "export", "format": "pdf"})

        samples = list(registry.collect())
        business_metrics = [s for s in samples if "business" in s.name]
        assert len(business_metrics) > 0

    def test_gauge_metrics(self, metrics, registry):
        """Test gauge metrics for current values."""
        active_connections = Gauge(
            'active_connections',
            'Number of active connections',
            registry=registry
        )

        active_connections.set(10)
        active_connections.inc()
        active_connections.dec(2)

        samples = list(registry.collect())
        gauge_metrics = [s for s in samples if "active_connections" in s.name]
        assert len(gauge_metrics) > 0

    def test_metrics_labels(self, metrics, registry):
        """Test metric labels for dimensional data."""
        counter = Counter(
            'test_counter',
            'Test counter with labels',
            ['method', 'status', 'service'],
            registry=registry
        )

        counter.labels(method='GET', status='200', service='{{ service_name }}').inc()
        counter.labels(method='POST', status='201', service='{{ service_name }}').inc(2)

        samples = list(registry.collect())
        assert any('test_counter' in s.name for s in samples)

    def test_metrics_export_format(self, metrics, registry):
        """Test Prometheus export format."""
        track_request("GET", "/test", 200, 0.1)

        # Get metrics in Prometheus format
        from prometheus_client import generate_latest
        output = generate_latest(registry).decode('utf-8')

        assert '# HELP' in output
        assert '# TYPE' in output
        assert 'http_requests_total' in output

class TestDistributedTracing:
    """Test distributed tracing with OpenTelemetry."""

    @pytest.fixture
    def tracer(self):
        """Create a test tracer."""
        return trace.get_tracer("{{ service_name }}.test")

    def test_span_creation(self, tracer):
        """Test creating and managing spans."""
        with tracer.start_as_current_span("test_operation") as span:
            span.set_attribute("service.name", "{{ service_name }}")
            span.set_attribute("operation.type", "test")
            span.set_attribute("user.id", 123)

            assert span is not None
            assert span.is_recording()

    def test_span_nesting(self, tracer):
        """Test nested span contexts."""
        with tracer.start_as_current_span("parent_operation") as parent:
            parent.set_attribute("level", "parent")

            with tracer.start_as_current_span("child_operation") as child:
                child.set_attribute("level", "child")

                with tracer.start_as_current_span("grandchild_operation") as grandchild:
                    grandchild.set_attribute("level", "grandchild")

                    # Verify span hierarchy
                    assert grandchild is not None
                    assert child is not None
                    assert parent is not None

    def test_span_status_and_errors(self, tracer):
        """Test span status and error recording."""
        with tracer.start_as_current_span("error_operation") as span:
            try:
                raise ValueError("Test error")
            except ValueError as e:
                span.record_exception(e)
                span.set_status(Status(StatusCode.ERROR, "Operation failed"))

            assert span.status.status_code == StatusCode.ERROR

    def test_span_attributes(self, tracer):
        """Test setting various span attributes."""
        with tracer.start_as_current_span("attributed_operation") as span:
            # Set different attribute types
            span.set_attribute("string_attr", "value")
            span.set_attribute("int_attr", 42)
            span.set_attribute("float_attr", 3.14)
            span.set_attribute("bool_attr", True)
            span.set_attribute("list_attr", ["a", "b", "c"])

            # Set semantic conventions
            span.set_attribute("http.method", "GET")
            span.set_attribute("http.url", "/api/{{ app_name }}/test")
            span.set_attribute("http.status_code", 200)

    def test_trace_context_propagation(self, tracer):
        """Test trace context propagation across services."""
        with tracer.start_as_current_span("service_a_operation") as span_a:
            trace_id = span_a.get_span_context().trace_id

            # Simulate context propagation to another service
            with tracer.start_as_current_span("service_b_operation") as span_b:
                # Both spans should share the same trace ID
                assert span_b.get_span_context().trace_id == trace_id

    def test_span_events(self, tracer):
        """Test adding events to spans."""
        with tracer.start_as_current_span("event_operation") as span:
            span.add_event("operation_started", {"timestamp": time.time()})

            # Simulate some processing
            time.sleep(0.1)

            span.add_event("checkpoint_reached", {"progress": 50})

            time.sleep(0.1)

            span.add_event("operation_completed", {"status": "success"})

class TestHealthChecks:
    """Test health check endpoints and monitoring."""

    @pytest.fixture
    def health_check(self):
        """Create health check instance."""
        return HealthCheck("{{ service_name }}")

    def test_basic_health_check(self, health_check):
        """Test basic health check response."""
        status = health_check.get_status()

        assert status["status"] in ["healthy", "unhealthy", "degraded"]
        assert "service" in status
        assert status["service"] == "{{ service_name }}"
        assert "timestamp" in status

    def test_component_health_checks(self, health_check):
        """Test individual component health checks."""
        components = ["database", "cache", "message_queue", "external_api"]

        for component in components:
            status = health_check.check_component(component)

            assert "name" in status
            assert "status" in status
            assert "response_time" in status
            assert status["name"] == component

    async def test_database_health(self, health_check):
        """Test database connectivity health check."""
        with patch('sqlalchemy.engine.Engine.execute') as mock_execute:
            mock_execute.return_value = MagicMock()

            result = await health_check.check_database()

            assert result["status"] == "healthy"
            assert result["response_time"] is not None
            mock_execute.assert_called_with("SELECT 1")

    async def test_cache_health(self, health_check):
        """Test cache connectivity health check."""
        with patch('redis.Redis.ping') as mock_ping:
            mock_ping.return_value = True

            result = await health_check.check_cache()

            assert result["status"] == "healthy"
            assert result["response_time"] is not None
            mock_ping.assert_called_once()

    def test_health_check_degraded_state(self, health_check):
        """Test degraded health state detection."""
        health_check.component_status = {
            "database": "healthy",
            "cache": "unhealthy",
            "message_queue": "healthy"
        }

        status = health_check.get_status()

        assert status["status"] == "degraded"
        assert "unhealthy_components" in status
        assert "cache" in status["unhealthy_components"]

    def test_health_check_thresholds(self, health_check):
        """Test health check thresholds and alerts."""
        # Test response time threshold
        health_check.response_time_threshold = 1.0  # 1 second

        with patch.object(health_check, 'check_database') as mock_check:
            mock_check.return_value = {"response_time": 1.5}  # Exceeds threshold

            status = health_check.get_status()
            assert "slow_components" in status

    def test_liveness_probe(self):
        """Test Kubernetes liveness probe endpoint."""
        response = get_health_status(probe_type="liveness")

        assert response["alive"] is True
        assert response["service"] == "{{ service_name }}"

    def test_readiness_probe(self):
        """Test Kubernetes readiness probe endpoint."""
        with patch('api.health.check_dependencies') as mock_check:
            mock_check.return_value = True

            response = get_health_status(probe_type="readiness")

            assert response["ready"] is True
            assert response["service"] == "{{ service_name }}"

class TestMetricsEndpoint:
    """Test metrics exposure endpoint."""

    def test_metrics_endpoint_format(self):
        """Test metrics endpoint returns Prometheus format."""
        with patch('prometheus_client.generate_latest') as mock_generate:
            mock_generate.return_value = b"# HELP test_metric\n# TYPE test_metric counter\ntest_metric 42"

            response = metrics_endpoint()

            assert response.status_code == 200
            assert response.headers["Content-Type"] == "text/plain"
            assert b"# HELP" in response.body
            assert b"# TYPE" in response.body

    def test_metrics_endpoint_auth(self):
        """Test metrics endpoint authentication if configured."""
        with patch('api.metrics.require_metrics_auth', return_value=False):
            response = metrics_endpoint()
            assert response.status_code == 401

class TestObservabilityIntegration:
    """Test integration of all observability components."""

    async def test_request_flow_observability(self):
        """Test complete observability for a request flow."""
        tracer = trace.get_tracer("{{ service_name }}")
        logger = get_logger("{{ service_name }}")

        with tracer.start_as_current_span("http_request") as span:
            span.set_attribute("http.method", "POST")
            span.set_attribute("http.url", "/api/{{ app_name }}/entity")

            # Log the request
            logger.info(
                "Request received",
                method="POST",
                path="/api/{{ app_name }}/entity",
                trace_id=span.get_span_context().trace_id
            )

            # Track metrics
            start_time = time.time()

            try:
                # Simulate processing
                time.sleep(0.1)

                # Log success
                logger.info("Request processed successfully")

                # Track success metrics
                track_request(
                    method="POST",
                    endpoint="/api/{{ app_name }}/entity",
                    status_code=201,
                    duration=time.time() - start_time
                )

                span.set_status(Status(StatusCode.OK))

            except Exception as e:
                # Log error
                logger.error("Request failed", error=str(e))

                # Track error metrics
                track_error(
                    error_type=type(e).__name__,
                    category="request_processing",
                    endpoint="/api/{{ app_name }}/entity"
                )

                span.record_exception(e)
                span.set_status(Status(StatusCode.ERROR))

    def test_observability_configuration(self):
        """Test observability configuration from environment."""
        with patch.dict('os.environ', {
            'OTEL_EXPORTER_OTLP_ENDPOINT': 'http://localhost:4317',
            'OTEL_SERVICE_NAME': '{{ service_name }}',
            'OTEL_LOG_LEVEL': 'debug',
            'METRICS_PORT': '9090',
        }):
            from core.observability import ObservabilityConfig

            config = ObservabilityConfig()

            assert config.otlp_endpoint == 'http://localhost:4317'
            assert config.service_name == '{{ service_name }}'
            assert config.log_level == 'debug'
            assert config.metrics_port == 9090